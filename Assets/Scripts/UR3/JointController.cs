using System;using System.Collections;using System.Collections.Generic;using UnityEngine;using static UnityEngine.KeyCode;public class JointEventArgs : EventArgs{    public int Step { get; set; }    public float CurrentPosition { get; set; }    public float TargetPosition { get; set; }    public float Speed { get; set; }    public JointEventArgs(int nStep, float fSpeed, float fCurr, float fTarget)    {        Step = nStep;        CurrentPosition = fCurr;        TargetPosition = fTarget;        Speed = fSpeed;    }}public class JointController : MonoBehaviour, IMotorControl{    public delegate void JointMoveCallback(object sender, JointEventArgs e);    public int Index { get; set; }    public string Name { get; set; }    public int MaxFrame { get; set; } = 0;    public float MaxSpeed { get; set; } = 0.0F;    public SpeedRule SpeedMode { get; set; } = SpeedRule.Trapezoid;    public SyncRule SyncMode { get; set; } = SyncRule.Async;    public OperationMode ControlMode { get; set; } = OperationMode.Auto;    public BreakStatus Break { get; set; } = BreakStatus.Hold;    public float CurrentPosition => (_pArticulation == null) ? 0.0F : Mathf.Rad2Deg * _pArticulation.jointPosition[0];    public float TargetPosition { get; set; }    private ArticulationBody _pArticulation;    private int _nCurrFrame = 0;    private ISpeedControl _pSpeedController;    private float _fOperatedPos = 0.0F;    public event JointMoveCallback OnJointMoveEvent;    public event JointMoveCallback OnJointStopEvent;    // Start is called before the first frame update    private void Start()    {        MaxFrame = 0;        MaxSpeed = 0.0F;        SpeedMode = SpeedRule.Trapezoid;        SyncMode = SyncRule.Async;        ControlMode = OperationMode.Auto;        Break = BreakStatus.Hold;        _pArticulation = GetComponent<ArticulationBody>();        _fOperatedPos = CurrentPosition;        _pSpeedController = SpeedMode switch        {            SpeedRule.None => new NormalControl(Time.fixedDeltaTime),            SpeedRule.Trapezoid => new TrapezoidControl(Time.fixedDeltaTime),            SpeedRule.Triangle => new TriangleControl(Time.fixedDeltaTime),            _ => _pSpeedController        };        UpdateParameter();    }    public void SetLimit(float fNegLimit, float fPosLimit)    {        ArticulationDrive pDrive = _pArticulation.xDrive;        pDrive.lowerLimit = Mathf.Min(fNegLimit, fPosLimit);        pDrive.upperLimit = Mathf.Max(fNegLimit, fPosLimit);        _pArticulation.xDrive = pDrive;    }    public void UpdateParameter()    {        _nCurrFrame = 0;        if (_pSpeedController == null) return;        switch (SyncMode)        {            case SyncRule.Async:                _pSpeedController.SetPosition(CurrentPosition, TargetPosition);                _pSpeedController.MaxSpeed = MaxSpeed;                MaxFrame = _pSpeedController.MaxFrame;                Break = BreakStatus.Release;                break;            case SyncRule.FrameSync:                _pSpeedController.SetPosition(CurrentPosition, TargetPosition);                _pSpeedController.MaxFrame = MaxFrame;                MaxSpeed = _pSpeedController.MaxSpeed;                Break = BreakStatus.Release;                break;            default:                throw new ArgumentOutOfRangeException();        }    }    private void Update()    {        if (ControlMode != OperationMode.Teaching) return;        if (Break == BreakStatus.Hold)        {            _fOperatedPos = CurrentPosition;            return;        }        _fOperatedPos += CommonFunctions.GetInputKeys(new[] { LeftArrow, UpArrow, RightArrow, DownArrow }) switch        {            LeftArrow => -MaxSpeed * Time.fixedDeltaTime / 2.0F,            UpArrow => -MaxSpeed * Time.fixedDeltaTime,            RightArrow => MaxSpeed * Time.fixedDeltaTime / 2.0F,            DownArrow => MaxSpeed * Time.fixedDeltaTime,            _ => 0.0F        };        Debug.Log($"[TEACHING] Index={Index} CurrentPos={CurrentPosition} TargetPos={_fOperatedPos} Speed={MaxSpeed}");        ArticulationDrive pDrive = _pArticulation.xDrive;        pDrive.target = _fOperatedPos;        _pArticulation.xDrive = pDrive;    }    // Update is called on fixed frequency    private void FixedUpdate()    {        if (ControlMode != OperationMode.Auto) return;        if (Break == BreakStatus.Hold)        {            _fOperatedPos = CurrentPosition;            return;        }        if (_nCurrFrame >= MaxFrame)        {            OnJointStopEvent?.Invoke(this, new JointEventArgs(0, 0.0F, CurrentPosition, CurrentPosition));            Break = BreakStatus.Hold;            return;        }        _fOperatedPos = _pSpeedController.GetPosition(_nCurrFrame);        OnJointMoveEvent?.Invoke(this,            new JointEventArgs(_nCurrFrame, _pSpeedController.GetSpeed(_nCurrFrame), CurrentPosition,                _fOperatedPos));        Debug.Log($"[TEMP] {Name}: Operate={_fOperatedPos}, Frame={_nCurrFrame}, Speed={_pSpeedController.GetSpeed(_nCurrFrame)}, Curr={CurrentPosition}");        ArticulationDrive pDrive = _pArticulation.xDrive;        pDrive.target = _fOperatedPos;        _pArticulation.xDrive = pDrive;        _nCurrFrame += 1;    }}